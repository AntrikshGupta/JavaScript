// let score = 5
// let score = "33"
// let score = "33ab"                  //Input is not a number but still it gets changed to a Number type, but value is NaN

// console.log(typeof score);          //Two methods of checking type of 
// console.log(typeof(score));

// let changedValue = Number(score)
// console.log(typeof changedValue);

// console.log(changedValue);          //NaN

// let val = null
// let c_val = Number(val)
// console.table([val,typeof val, c_val, typeof c_val])        null is type casted into a number with value = 0

// let val = undefined
// let c_val = Number(val)
// console.table([val,typeof val, c_val, typeof c_val])        undefined is typecasted to number with value = NaN

// let val = true
// let c_val = Number(val)
// console.table([val,typeof val, c_val, typeof c_val])        boolean is typecasted into a number with value of true = 1, false = 0

// let val = 1
// let new_val = Boolean(val)
// console.log(new_val);
// console.log(typeof new_val);

// let num = 33
// let num_str = String(num)
// console.log(num_str);
// console.log(typeof num_str);

//***************************************OPERATIONS*****************************************//

// let value = 3
// let negValue = -value
// console.log(negValue);

// let str1= "hello"
// let str2 = " Antriksh"
// let str3 = str1 + str2
// console.log(str3);

// console.log(2 + "1")                 converted to 21
// console.log("1" + 2);                converted to 12
// console.log("1"+ 2 + 2);             converted to 122 , as "1" is a string type so rest all converted to it
// console.log(3+5+"9");                converted to 89, as first 3 + 5 are added and then "9" changed the output to stringtype
// console.log((3 + 4 )*5%3);           7 * 5 = 35, 35 % 3 = 2

// console.log(+true);

// console.log(null > 0);
// console.log(null >=0);                  here null is first converted to a number then it is compared 
// console.log(null == 0);                 this works differently in == operator
















